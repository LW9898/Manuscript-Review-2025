function [featureTable,ensembleStatistics,outputTable] = diagnosticFeatures(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  ensembleStatistics: A table containing ensemble statistics.
%  outputTable: A table containing the computation results.
%
% This function computes signals:
%  Var1_interp/Var1
%  Var1_mean/Var1
%  Var1_tsproc/Var1
%  Var1_res/Var1
%
% This function computes spectra:
%  Var1_ps/SpectrumData
%
% This function computes features:
%  Var1_sigstats/ClearanceFactor
%  Var1_sigstats/CrestFactor
%  Var1_sigstats/ImpulseFactor
%  Var1_sigstats/Kurtosis
%  Var1_sigstats/Mean
%  Var1_sigstats/PeakValue
%  Var1_sigstats/RMS
%  Var1_sigstats/SINAD
%  Var1_sigstats/SNR
%  Var1_sigstats/ShapeFactor
%  Var1_sigstats/Skewness
%  Var1_sigstats/Std
%  Var1_sigstats/THD
%  Var1_tsfeat/Minimum
%  Var1_tsfeat/Median
%  Var1_tsfeat/Maximum
%  Var1_tsfeat/Q1
%  Var1_tsfeat/Q3
%  Var1_tsfeat/IQR
%  Var1_tsmodel/Coef1
%  Var1_tsmodel/Freq1
%  Var1_tsmodel/Damp1
%  Var1_tsmodel/MSE
%  Var1_tsmodel/MAE
%  Var1_tsmodel/AIC
%  Var1_tsmodel/Mean
%  Var1_tsmodel/Variance
%  Var1_tsmodel/RMS
%  Var1_tsmodel/Kurtosis
%  Var1_res_sigstats/ClearanceFactor
%  Var1_res_sigstats/CrestFactor
%  Var1_res_sigstats/ImpulseFactor
%  Var1_res_sigstats/Kurtosis
%  Var1_res_sigstats/Mean
%  Var1_res_sigstats/PeakValue
%  Var1_res_sigstats/RMS
%  Var1_res_sigstats/SINAD
%  Var1_res_sigstats/SNR
%  Var1_res_sigstats/ShapeFactor
%  Var1_res_sigstats/Skewness
%  Var1_res_sigstats/Std
%  Var1_res_sigstats/THD
%  Var1_res_tsfeat/Minimum
%  Var1_res_tsfeat/Median
%  Var1_res_tsfeat/Maximum
%  Var1_res_tsfeat/Q1
%  Var1_res_tsfeat/Q3
%  Var1_res_tsfeat/IQR
%  Var1_res_tsmodel/Coef1
%  Var1_res_tsmodel/Freq1
%  Var1_res_tsmodel/Damp1
%  Var1_res_tsmodel/MSE
%  Var1_res_tsmodel/MAE
%  Var1_res_tsmodel/AIC
%  Var1_res_tsmodel/Mean
%  Var1_res_tsmodel/Variance
%  Var1_res_tsmodel/RMS
%  Var1_res_tsmodel/Kurtosis
%  Var1_ps_spec/PeakAmp1
%  Var1_ps_spec/PeakFreq1
%  Var1_ps_spec/BandPower
%  Var1_tsproc_sigstats/ClearanceFactor
%  Var1_tsproc_sigstats/CrestFactor
%  Var1_tsproc_sigstats/ImpulseFactor
%  Var1_tsproc_sigstats/Kurtosis
%  Var1_tsproc_sigstats/Mean
%  Var1_tsproc_sigstats/PeakValue
%  Var1_tsproc_sigstats/RMS
%  Var1_tsproc_sigstats/SINAD
%  Var1_tsproc_sigstats/SNR
%  Var1_tsproc_sigstats/ShapeFactor
%  Var1_tsproc_sigstats/Skewness
%  Var1_tsproc_sigstats/Std
%  Var1_tsproc_sigstats/THD
%  Var1_tsproc_tsfeat/Minimum
%  Var1_tsproc_tsfeat/Median
%  Var1_tsproc_tsfeat/Maximum
%  Var1_tsproc_tsfeat/Q1
%  Var1_tsproc_tsfeat/Q3
%  Var1_tsproc_tsfeat/IQR
%  Var1_tsproc_tsmodel/Coef1
%  Var1_tsproc_tsmodel/Freq1
%  Var1_tsproc_tsmodel/Damp1
%  Var1_tsproc_tsmodel/MSE
%  Var1_tsproc_tsmodel/MAE
%  Var1_tsproc_tsmodel/AIC
%  Var1_tsproc_tsmodel/Mean
%  Var1_tsproc_tsmodel/Variance
%  Var1_tsproc_tsmodel/RMS
%  Var1_tsproc_tsmodel/Kurtosis
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 2024-07-02 10:47:20

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',["Var1";"label"]);

% Initialize ensemble statistics.
ensembleStatistics = table;

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"Var1_interp";"Var1_tsproc";"Var1_ps";"Var1_sigstats";"Var1_tsfeat";"Var1_tsmodel";"Var1_ps_spec";"Var1_tsproc_sigstats";"Var1_tsproc_tsfeat";"Var1_tsproc_tsmodel"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = "Var1";

% Initialize a cell array to store all the results.
allMembersResult = {};

% Compute sampling frequency for interpolation.
member1 = read(outputEnsemble);

data = readMemberData(member1,"Var1/Var1");
time = (0:1:(0+1*(height(data)-1)));
Var1_interp_Fs = effectivefs(time);
reset(outputEnsemble)

% Initialize a table to store accumulated results.
accumulator = table;

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Update accumulator.
    if isempty(accumulator)
        accumulator.Var1_interp = {table};
        accumulator.Properties.UserData = [ ...
            ["Var1_interp"; "Var1_mean"]];
    end

    % Get all input variables.
    Var1 = readMemberData(member,"Var1","Var1");
    iv = (0:1:(height(Var1)-1)*1)';
    Var1.Sample = iv;

    % Initialize a table to store results.
    memberResult = table;

    %% Interpolation
    try
        % Compute interpolation
        time = Var1.Sample;

        % Get sampling period
        samplePeriod = 1/Var1_interp_Fs;
        ivStart = min(time);
        ivEnd = max(time);

        if rem(ivStart, samplePeriod) ~= 0
            gridStartIdx = ceil((ivStart+eps)/samplePeriod);
        else
            gridStartIdx = ivStart/samplePeriod;
        end

        if rem(ivEnd, samplePeriod) ~= 0
            gridEndIdx = floor((ivEnd-eps)/samplePeriod);
        else
            gridEndIdx = ivEnd/samplePeriod;
        end

        ivGrid = (gridStartIdx:gridEndIdx)'*samplePeriod;
        % Interpolation
        val = interp1(time,Var1.Var1,ivGrid,'linear',NaN);
        Var1_interp = table(ivGrid,val,'VariableNames',{'Sample','Var1'});
    catch
        % Package computed signal into a table.
        Var1_interp = table(NaN,NaN,'VariableNames',{'Sample','Var1'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_interp},'VariableNames',{'Var1_interp'})]; %#ok<AGROW>

    %% EnsembleStatistics
    try
        newData = Var1_interp;
        % Get new info
        newIV = newData.Sample;
        newDV = newData.Var1;

        %% Get accumulator
        accumData = accumulator.Var1_interp{1};

        % Update accumulator sum and count with current data.
        newCount = double(~isnan(newDV));
        if isempty(accumData)
            accumData = table(newIV, newDV, newCount, 'VariableNames', ["IV","Sum","Count"]);
        else
            accumIV = accumData.IV;
            [~, idxAccum, idxNewData] = intersect(accumIV, newIV);

            accumData.Sum(idxAccum) = sum([accumData.Sum(idxAccum),newDV(idxNewData)],2,'omitnan');
            accumData.Count(idxAccum) = accumData.Count(idxAccum) + newCount(idxNewData);

            % Find the non-overlapping indices
            if~isempty(newIV) && ~isdatetime(newIV(1)) && all(isnan(newIV))
                idxTblComp = false;
            else
                idxTblComp = true(size(newIV));
                idxTblComp(idxNewData) = false;
            end
            if any(idxTblComp)
                count = ones(sum(idxTblComp), 1);
                tbl2merge = table(newIV(idxTblComp),newDV(idxTblComp),count,'VariableNames',["IV","Sum","Count"]);
                accumData = outerjoin(accumData, tbl2merge,'Keys',["IV","Sum","Count"],'MergeKeys', true);
            end
        end

        % Save updated accumulated data back to the accumulator.
        accumulator.Var1_interp = {accumData};
    catch
        % Store computed signal in a table.
        accumData = array2table(NaN(1,3),'VariableNames',["IV", "Count", "Sum"]);
        accumulator.Var1_interp = {accumData};
    end

    %% TimeSeriesProcessing
    try
        % Apply time series processing steps.
        x = Var1.Var1;
        t = Var1.Sample;
        % Detrend the signal.
        order = 1;
        x = detrend(x, order, 'omitnan', 'SamplePoints', t);

        % Store computed signal in a table.
        Var1_tsproc = table(t,x,'VariableNames',{'Sample','Var1'});
    catch
        % Store computed signal in a table.
        data = NaN(1,2);
        Var1_tsproc = array2table(data,'VariableNames',{'Sample','Var1'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_tsproc},'VariableNames',{'Var1_tsproc'})]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "samples";

        % Compute effective sampling rate.
        tNumeric = time2num(Var1.Sample,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x_raw = Var1.Var1;
        if irregular
            x = resample(x_raw,tNumeric,Fs,'linear');
        else
            x = x_raw;
        end

        % Set Welch spectrum parameters.
        L = fix(length(x)/4.5);
        noverlap = fix(L*50/100);
        win = hamming(L);

        % Compute the power spectrum.
        [ps,f] = pwelch(x,win,noverlap,[],Fs);
        w = 2*pi*f;
        factor = 1/2/pi;
        w = factor*w;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
        ps.Properties.VariableUnits = {'cycles/sample', ''};
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        Var1_ps = ps;
    catch
        Var1_ps = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_ps},'VariableNames',{'Var1_ps'})]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = Var1.Var1;
        ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        CrestFactor = peak2rms(inputSignal);
        ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Kurtosis = kurtosis(inputSignal);
        Mean = mean(inputSignal,'omitnan');
        PeakValue = max(abs(inputSignal));
        RMS = rms(inputSignal,'omitnan');
        SINAD = sinad(inputSignal);
        SNR = snr(inputSignal);
        ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
        Skewness = skewness(inputSignal);
        Std = std(inputSignal,'omitnan');
        THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

        % Store computed features in a table.
        featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
        Var1_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,13);
        featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
        Var1_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_sigstats},'VariableNames',{'Var1_sigstats'})]; %#ok<AGROW>

    %% TimeSeriesFeatures
    try
        % Compute time series features.
        inputSignal = Var1.Var1;
        quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

        % Extract individual feature values.
        Minimum = min(inputSignal);
        Median = median(inputSignal, 'omitnan');
        Maximum = max(inputSignal);
        Q1 = quartiles(1);
        Q3 = quartiles(3);
        IQR = quartiles(3)-quartiles(1);

        % Concatenate signal features.
        featureValues = [Minimum,Median,Maximum,Q1,Q3,IQR];

        % Store computed features in a table.
        featureNames = {'Minimum','Median','Maximum','Q1','Q3','IQR'};
        Var1_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,6);
        featureNames = {'Minimum','Median','Maximum','Q1','Q3','IQR'};
        Var1_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_tsfeat},'VariableNames',{'Var1_tsfeat'})]; %#ok<AGROW>

    %% TimeSeriesModelFeatures
    try
        % Compute model-based time series features.
        x = Var1.Var1;
        t = Var1.Sample;
        y = x - mean(x,'omitnan');
        N = numel(x);

        % Estimate autoregressive model.
        p = 10;
        R = xcorr(y,p,'biased');
        R(1:p) = [];
        [a,Ep] = levinson(R,p);

        % Compute effective sampling rate.
        tNumeric = time2num(t,"seconds");
        Fs = effectivefs(tNumeric);

        % Compute model poles.
        r = sort(roots(a),'descend');
        s = Fs*log(r);
        Fn = abs(s)/2/pi;
        Zn = -real(s)./abs(s);

        % Estimate process noise.
        w = filter(a,1,y);

        % Estimate model residuals.
        e = filter(a,1,x);

        % Extract individual feature values.
        Coef1 = a(2);
        Freq1 = Fn(1);
        Damp1 = Zn(1);
        MSE = var(w,'omitnan');
        MAE = mean(abs(w),'omitnan');
        AIC = log(Ep) + 2*p/N;
        Mean = mean(e,'omitnan');
        Variance = var(e,'omitnan');
        RMS = rms(e,'omitnan');
        Kurtosis = kurtosis(e);

        % Concatenate signal features.
        featureValues = [Coef1,Freq1,Damp1,MSE,MAE,AIC,Mean,Variance,RMS,Kurtosis];

        % Store computed features in a table.
        featureNames = {'Coef1','Freq1','Damp1','MSE','MAE','AIC','Mean','Variance','RMS','Kurtosis'};
        Var1_tsmodel = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,10);
        featureNames = {'Coef1','Freq1','Damp1','MSE','MAE','AIC','Mean','Variance','RMS','Kurtosis'};
        Var1_tsmodel = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_tsmodel},'VariableNames',{'Var1_tsmodel'})]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = 2*pi;
        ps = Var1_ps.SpectrumData;
        w = Var1_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0) & (w<=factor*0.5);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Store computed features in a table.
        featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
        Var1_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,3);
        featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
        Var1_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_ps_spec},'VariableNames',{'Var1_ps_spec'})]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = Var1_tsproc.Var1;
        ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        CrestFactor = peak2rms(inputSignal);
        ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Kurtosis = kurtosis(inputSignal);
        Mean = mean(inputSignal,'omitnan');
        PeakValue = max(abs(inputSignal));
        RMS = rms(inputSignal,'omitnan');
        SINAD = sinad(inputSignal);
        SNR = snr(inputSignal);
        ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
        Skewness = skewness(inputSignal);
        Std = std(inputSignal,'omitnan');
        THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

        % Store computed features in a table.
        featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
        Var1_tsproc_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,13);
        featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
        Var1_tsproc_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_tsproc_sigstats},'VariableNames',{'Var1_tsproc_sigstats'})]; %#ok<AGROW>

    %% TimeSeriesFeatures
    try
        % Compute time series features.
        inputSignal = Var1_tsproc.Var1;
        quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

        % Extract individual feature values.
        Minimum = min(inputSignal);
        Median = median(inputSignal, 'omitnan');
        Maximum = max(inputSignal);
        Q1 = quartiles(1);
        Q3 = quartiles(3);
        IQR = quartiles(3)-quartiles(1);

        % Concatenate signal features.
        featureValues = [Minimum,Median,Maximum,Q1,Q3,IQR];

        % Store computed features in a table.
        featureNames = {'Minimum','Median','Maximum','Q1','Q3','IQR'};
        Var1_tsproc_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,6);
        featureNames = {'Minimum','Median','Maximum','Q1','Q3','IQR'};
        Var1_tsproc_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_tsproc_tsfeat},'VariableNames',{'Var1_tsproc_tsfeat'})]; %#ok<AGROW>

    %% TimeSeriesModelFeatures
    try
        % Compute model-based time series features.
        x = Var1_tsproc.Var1;
        t = Var1_tsproc.Sample;
        y = x - mean(x,'omitnan');
        N = numel(x);

        % Estimate autoregressive model.
        p = 10;
        R = xcorr(y,p,'biased');
        R(1:p) = [];
        [a,Ep] = levinson(R,p);

        % Compute effective sampling rate.
        tNumeric = time2num(t,"seconds");
        Fs = effectivefs(tNumeric);

        % Compute model poles.
        r = sort(roots(a),'descend');
        s = Fs*log(r);
        Fn = abs(s)/2/pi;
        Zn = -real(s)./abs(s);

        % Estimate process noise.
        w = filter(a,1,y);

        % Estimate model residuals.
        e = filter(a,1,x);

        % Extract individual feature values.
        Coef1 = a(2);
        Freq1 = Fn(1);
        Damp1 = Zn(1);
        MSE = var(w,'omitnan');
        MAE = mean(abs(w),'omitnan');
        AIC = log(Ep) + 2*p/N;
        Mean = mean(e,'omitnan');
        Variance = var(e,'omitnan');
        RMS = rms(e,'omitnan');
        Kurtosis = kurtosis(e);

        % Concatenate signal features.
        featureValues = [Coef1,Freq1,Damp1,MSE,MAE,AIC,Mean,Variance,RMS,Kurtosis];

        % Store computed features in a table.
        featureNames = {'Coef1','Freq1','Damp1','MSE','MAE','AIC','Mean','Variance','RMS','Kurtosis'};
        Var1_tsproc_tsmodel = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,10);
        featureNames = {'Coef1','Freq1','Damp1','MSE','MAE','AIC','Mean','Variance','RMS','Kurtosis'};
        Var1_tsproc_tsmodel = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_tsproc_tsmodel},'VariableNames',{'Var1_tsproc_tsmodel'})]; %#ok<AGROW>

    % Append all member results to the cell array.
    allMembersResult = [allMembersResult; {memberResult}]; %#ok<AGROW>
end

% Write the results for all members to the ensemble.
writeToMembers(outputEnsemble,allMembersResult)

% Compute reduce results
allNames = accumulator.Properties.UserData;
meanVarIdx = find(contains(allNames(2,:), "mean"));
% Reduce ensemble mean
for idx = meanVarIdx
    accumData = accumulator.(allNames(1,idx)){1};
    ensembleMean = accumData.Sum./accumData.Count;
    ensembleStatistics.(allNames(2,idx)) = {table(accumData.IV,ensembleMean,'VariableNames',["Sample","Var1"])};
end

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"Var1_res";"Var1_res_sigstats";"Var1_res_tsfeat";"Var1_res_tsmodel"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = "Var1_interp";

% Initialize a cell array to store all the results.
allMembersResult = {};

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Get all input variables.
    Var1_interp = readMemberData(member,"Var1_interp",["Sample","Var1"]);
    Var1_mean = readMemberData(ensembleStatistics,"Var1_mean",["Sample","Var1"]);

    % Initialize a table to store results.
    memberResult = table;

    %% SubtractReference
    try
        % Subtract reference from input signal.
        [~, SRidx] = intersect(Var1_interp.Sample, Var1_mean.Sample);
        difference = Var1_interp.Var1 - Var1_mean.Var1(SRidx);

        % Store computed signal in a table.
        Var1_res = table(Var1_interp.Sample, difference, 'VariableNames', {'Sample', 'Var1'});
    catch
        % Store computed signal in a table.
        Var1_res = array2table(NaN(1,2),'VariableNames',{'Sample','Var1'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_res},'VariableNames',{'Var1_res'})]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = Var1_res.Var1;
        ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        CrestFactor = peak2rms(inputSignal);
        ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Kurtosis = kurtosis(inputSignal);
        Mean = mean(inputSignal,'omitnan');
        PeakValue = max(abs(inputSignal));
        RMS = rms(inputSignal,'omitnan');
        SINAD = sinad(inputSignal);
        SNR = snr(inputSignal);
        ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
        Skewness = skewness(inputSignal);
        Std = std(inputSignal,'omitnan');
        THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

        % Store computed features in a table.
        featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
        Var1_res_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,13);
        featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
        Var1_res_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_res_sigstats},'VariableNames',{'Var1_res_sigstats'})]; %#ok<AGROW>

    %% TimeSeriesFeatures
    try
        % Compute time series features.
        inputSignal = Var1_res.Var1;
        quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

        % Extract individual feature values.
        Minimum = min(inputSignal);
        Median = median(inputSignal, 'omitnan');
        Maximum = max(inputSignal);
        Q1 = quartiles(1);
        Q3 = quartiles(3);
        IQR = quartiles(3)-quartiles(1);

        % Concatenate signal features.
        featureValues = [Minimum,Median,Maximum,Q1,Q3,IQR];

        % Store computed features in a table.
        featureNames = {'Minimum','Median','Maximum','Q1','Q3','IQR'};
        Var1_res_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,6);
        featureNames = {'Minimum','Median','Maximum','Q1','Q3','IQR'};
        Var1_res_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_res_tsfeat},'VariableNames',{'Var1_res_tsfeat'})]; %#ok<AGROW>

    %% TimeSeriesModelFeatures
    try
        % Compute model-based time series features.
        x = Var1_res.Var1;
        t = Var1_res.Sample;
        y = x - mean(x,'omitnan');
        N = numel(x);

        % Estimate autoregressive model.
        p = 10;
        R = xcorr(y,p,'biased');
        R(1:p) = [];
        [a,Ep] = levinson(R,p);

        % Compute effective sampling rate.
        tNumeric = time2num(t,"seconds");
        Fs = effectivefs(tNumeric);

        % Compute model poles.
        r = sort(roots(a),'descend');
        s = Fs*log(r);
        Fn = abs(s)/2/pi;
        Zn = -real(s)./abs(s);

        % Estimate process noise.
        w = filter(a,1,y);

        % Estimate model residuals.
        e = filter(a,1,x);

        % Extract individual feature values.
        Coef1 = a(2);
        Freq1 = Fn(1);
        Damp1 = Zn(1);
        MSE = var(w,'omitnan');
        MAE = mean(abs(w),'omitnan');
        AIC = log(Ep) + 2*p/N;
        Mean = mean(e,'omitnan');
        Variance = var(e,'omitnan');
        RMS = rms(e,'omitnan');
        Kurtosis = kurtosis(e);

        % Concatenate signal features.
        featureValues = [Coef1,Freq1,Damp1,MSE,MAE,AIC,Mean,Variance,RMS,Kurtosis];

        % Store computed features in a table.
        featureNames = {'Coef1','Freq1','Damp1','MSE','MAE','AIC','Mean','Variance','RMS','Kurtosis'};
        Var1_res_tsmodel = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,10);
        featureNames = {'Coef1','Freq1','Damp1','MSE','MAE','AIC','Mean','Variance','RMS','Kurtosis'};
        Var1_res_tsmodel = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Var1_res_tsmodel},'VariableNames',{'Var1_res_tsmodel'})]; %#ok<AGROW>

    % Append all member results to the cell array.
    allMembersResult = [allMembersResult; {memberResult}]; %#ok<AGROW>
end

% Write the results for all members to the ensemble.
writeToMembers(outputEnsemble,allMembersResult)

% Gather all features into a table.
selectedFeatureNames = ["label","Var1_sigstats/ClearanceFactor","Var1_sigstats/CrestFactor","Var1_sigstats/ImpulseFactor","Var1_sigstats/Kurtosis","Var1_sigstats/Mean","Var1_sigstats/PeakValue","Var1_sigstats/RMS","Var1_sigstats/SINAD","Var1_sigstats/SNR","Var1_sigstats/ShapeFactor","Var1_sigstats/Skewness","Var1_sigstats/Std","Var1_sigstats/THD","Var1_tsfeat/Minimum","Var1_tsfeat/Median","Var1_tsfeat/Maximum","Var1_tsfeat/Q1","Var1_tsfeat/Q3","Var1_tsfeat/IQR","Var1_tsmodel/Coef1","Var1_tsmodel/Freq1","Var1_tsmodel/Damp1","Var1_tsmodel/MSE","Var1_tsmodel/MAE","Var1_tsmodel/AIC","Var1_tsmodel/Mean","Var1_tsmodel/Variance","Var1_tsmodel/RMS","Var1_tsmodel/Kurtosis","Var1_res_sigstats/ClearanceFactor","Var1_res_sigstats/CrestFactor","Var1_res_sigstats/ImpulseFactor","Var1_res_sigstats/Kurtosis","Var1_res_sigstats/Mean","Var1_res_sigstats/PeakValue","Var1_res_sigstats/RMS","Var1_res_sigstats/SINAD","Var1_res_sigstats/SNR","Var1_res_sigstats/ShapeFactor","Var1_res_sigstats/Skewness","Var1_res_sigstats/Std","Var1_res_sigstats/THD","Var1_res_tsfeat/Minimum","Var1_res_tsfeat/Median","Var1_res_tsfeat/Maximum","Var1_res_tsfeat/Q1","Var1_res_tsfeat/Q3","Var1_res_tsfeat/IQR","Var1_res_tsmodel/Coef1","Var1_res_tsmodel/Freq1","Var1_res_tsmodel/Damp1","Var1_res_tsmodel/MSE","Var1_res_tsmodel/MAE","Var1_res_tsmodel/AIC","Var1_res_tsmodel/Mean","Var1_res_tsmodel/Variance","Var1_res_tsmodel/RMS","Var1_res_tsmodel/Kurtosis","Var1_ps_spec/PeakAmp1","Var1_ps_spec/PeakFreq1","Var1_ps_spec/BandPower","Var1_tsproc_sigstats/ClearanceFactor","Var1_tsproc_sigstats/CrestFactor","Var1_tsproc_sigstats/ImpulseFactor","Var1_tsproc_sigstats/Kurtosis","Var1_tsproc_sigstats/Mean","Var1_tsproc_sigstats/PeakValue","Var1_tsproc_sigstats/RMS","Var1_tsproc_sigstats/SINAD","Var1_tsproc_sigstats/SNR","Var1_tsproc_sigstats/ShapeFactor","Var1_tsproc_sigstats/Skewness","Var1_tsproc_sigstats/Std","Var1_tsproc_sigstats/THD","Var1_tsproc_tsfeat/Minimum","Var1_tsproc_tsfeat/Median","Var1_tsproc_tsfeat/Maximum","Var1_tsproc_tsfeat/Q1","Var1_tsproc_tsfeat/Q3","Var1_tsproc_tsfeat/IQR","Var1_tsproc_tsmodel/Coef1","Var1_tsproc_tsmodel/Freq1","Var1_tsproc_tsmodel/Damp1","Var1_tsproc_tsmodel/MSE","Var1_tsproc_tsmodel/MAE","Var1_tsproc_tsmodel/AIC","Var1_tsproc_tsmodel/Mean","Var1_tsproc_tsmodel/Variance","Var1_tsproc_tsmodel/RMS","Var1_tsproc_tsmodel/Kurtosis"];
featureTable = readFeatureTable(outputEnsemble,'Features',selectedFeatureNames);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
if nargout > 1
    outputTable = readall(outputEnsemble);
end
end
